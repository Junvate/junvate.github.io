---
layout:     post
title:      计算机组成原理
subtitle:   计算机组成原理复习
date:       2025-04-26
author:     Junvate
header-img: img/post-bg-cook.jpg
catalog: true
tags:
    - 保研复习
---
参考 https://blog.csdn.net/weixin_45260385/article/details/106640747

# 第一章 计算机系统概论 
计算机的组成；  
- 控制器
- 运算器
- 存储器
- 输入输出设备
## 冯诺依曼计算机
最重要的特点就是"存储程序"  无论是数据还是指令都是存储在存储器之中

I/O设备能够直接连接CPU吗？    
不能，因为两者速度不匹配，需要通过接口连接。
# 第二章 运算方法和运算器

 原码 反码 补码 计算

### 原码表示
- 符号位：最高位，0 表示正，1 表示负。
- 数值位：剩余的 n-1 位表示数值的绝对值的二进制形式。
- 例 (8位)：+5 -> 0000 0101  例 (8位)：-5 -> 1000 0101
- +0: 0000 0000  -0: 1000 0000  存在两个零的编码（+0 和 -0），这在计算中会带来不便。
- 表示范围：-(2^n-1 - 1)——(2^n-1 - 1)
### 反码表示
- 正数：反码与原码相同。  
- 负数的反码是对他的符号位之外按位取反（数值位按位取反）
- 例 (8位)：+5 -> 0000 0101   -5 反码 = 1111 1010 (将 1000 0101 除了符号位之外取反)
- +0: 0000 0000 (正数的反码是其本身) -0: 1111 1111 (将 +0 的各位取反得到)  仍然存在两个零的编码（+0 和 -0）。
- 表示范围：-(2^n-1 - 1)——(2^n-1 - 1)
### 补码表示
- 正数：补码与原码、反码相同。
- 负数的补码是反码+1
- 例 (8位)：+5 -> 0000 0101  
例子：-5 原码：1000 0101 补码：1111 1010 反码：1111 1011
- +0: 0000 0000   -0：1000 0000 1111 1111 00000000
- 特点：只有一个零的编码 (0000 0000)，解决了原码和反码中 +/-0 不同的问题。
- 表示范围：-(2^n-1)——(2^n-1 - 1) 补码的表示范围是不对称的，负数比正数多一个（因为 1000 0000 在补码中表示 -128，没有对应的正数 +128）。
为什么？？
![alt text](img/image.png)
![alt text](img/image-1.png)
### 总结与对比 (以 8 位为例)

| 特性 | 原码 (Sign-Magnitude) | 反码 (One's Complement) | 补码 (Two's Complement) | 移码 (Excess-128) |
|------|----------------------|------------------------|------------------------|-------------------|
| **符号位** | 0=+, 1=- | 0=+, 1=- | 0=+, 1=- | (无直接符号位) |
| **正数表示** | 符号位0, 其余为绝对值 | 符号位0, 其余为绝对值 | 符号位0, 其余为绝对值 | 真值 + 128 |
| **负数表示** | 符号位1, 其余为绝对值 | 对应正数各位取反 | 反码 + 1 | 真值 + 128 |
| **+0 表示** | `0000 0000` | `0000 0000` | `0000 0000` | `1000 0000` (表示0) |
| **-0 表示** | `1000 0000` | `1111 1111` | `0000 0000` | (无 -0) |
| **零表示个数** | 2 | 2 | **1** | **1** |
| **表示范围** | -127 ~ +127 | -127 ~ +127 | **-128 ~ +127** | -128 ~ +127 |
| **主要优点** | 直观 | 减法可变加法 | **算术运算统一简单** | **便于比较大小** |
| **主要缺点** | 两个零，运算复杂 | 两个零，循环进位 | 不直观，范围不对称 | 算术运算复杂 |
| **主要用途** | (早期或特定场景) | (早期或特定场景) | **通用整数表示** | **浮点数阶码** |
# 第三章 多层次的存储器

- ROM:只读存储器（Read-Only Memory，ROM）所存数据通常是装入整机前写入的，数据是非易失性的（断电不丢失）
- RAM: 随机存取存储器（Random Access Memory）与CPU直接交换数据的内部存储器。通常是易失性的（断电后数据丢失）。
    - DRAM: 动态随机存取存储器（Dynamic Random Access Memory）,是一种半导体存储器，常用于计算机的主内存（内存条）
    - SRAM: 静态随机存取存储器，只要供电，数据就能保持，不需要刷新，速度比DRAM快，但成本更高、密度更低。
- 闪存(Flash Memory):：是电子可擦除只读存储器(EEPROM)的变种，闪存掉电后信息不丢失，是一种非易失性存储器，闪存是一种半导体存储器，不能实现信息可读可写
- 高速缓冲存储器 (Cache):通常由速度很快的 SRAM 构成。容量较小，但速度接近CPU，用于存储CPU频繁访问的数据和指令，以弥补CPU与主存（DRAM）之间的速度差异
- 虚拟存储系统:
组成: 通常由主存 (如DRAM) 和辅存 (如大容量磁盘) 两层构成。

# 第四章 指令系统
- 寻址方式的核心作用：指令的寻址方式规定了如何找到该指令所要操作的数据（操作数）的位置。

- 操作数位置：操作数可以存放在不同的地方，如：   
指令本身内部 (立即寻址)  
CPU内部的寄存器 (寄存器寻址)  
内存单元 (多种内存寻址方式)  
## 寻址方式
- 隐含寻址：操作数的地址隐含在指令的操作码中，无需显式给出。   
CLC (Clear Carry Flag - 清除进位标志位)


- 立即寻址：操作数的值直接包含在指令代码中。  
MOV AX, 1234H (Move Immediate - 传送立即数)

- 直接寻址：指令中直接给出操作数在内存中的有效地址。  
MOV AX, [2000H] (Move from Memory - 从内存传送)

- 间接寻址：指令中给出的是存储操作数地址的内存单元的地址（即地址的地址，指针）。 
MOV AX, [[3000H]] (假设 [[...]] 代表内存间接寻址)

- 寄存器寻址：指令中指定寄存器的编号，操作数就在该寄存器中。  
MOV AX, BX (Move Register - 寄存器传送)

- 寄存器间接寻址：指令中指定寄存器的编号，该寄存器中存放的是操作数的有效地址。  
MOV AX, [BX] (Move from Memory add  ressed by Register - 从寄存器间接寻址的内存传送)


- 偏移寻址/位移寻址 (Displacement/Offset)：将指令中给出的位移量（偏移地址）与某个寄存器（如基址寄存器、变址寄存器或程序计数器PC）的内容相加，形成操作数的有效地址。     
MOV AX, [BX + 4] (Move with Base and Displacement - 基址加偏移量寻址)

- 堆栈寻址：操作数的地址隐含在堆栈指针 (SP) 中，通常是指向栈顶。     
例子: PUSH AX (Push onto Stack - 入栈)


# 第五章 中央处理器
## cpu主要功能
CPU 的主要功能:

- 指令控制 (Instruction Control): 负责控制程序中指令的执行顺序，确保程序按预定逻辑运行。

- 操作控制 (Operation Control): 对指令进行译码，产生执行该指令所需要的各种控制信号，指挥计算机各部件协调工作。

- 时间控制 (Timing Control): 提供精确的时序信号，控制指令中各个操作在何时发生，保证操作按正确的时序进行。

- 数据加工 (Data Processing): 执行算术运算（如加减乘除）和逻辑运算（如与、或、非、比较）。


## 指令执行的基本流程
指令执行的基本流程 (Instruction Execution Cycle):     
- 取指令（fetch instruction）：从内存中取出下一条要执行的指令     
- 分析译码（decode instruction）:对取出来的指令分析解码，确定操作和操作数——>产生对应的控制信号    
- 执行（excute）:根据译码结果和控制信号，执行指令所规定的操作
- (准备)取下一条指令: 在执行当前指令的同时或之后，计算并准备获取下一条指令的地址，以便开始下一个指令周期。