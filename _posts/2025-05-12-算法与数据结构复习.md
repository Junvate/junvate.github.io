---
layout:     post
title:      数据结构复习
subtitle:   数据结构复习
date:       2025-05-08
author:     Junvate
header-img: img/post-bg-cook.jpg
catalog: true
tags:
    - 保研复习
---

# 面试题集
![图片](/img/image-1.png)


## 各种排序算法
- 一个排序算法是稳定的，如果它能保证在排序完成后，具有相同键值（排序依据的值）的元素保持它们在输入序列中的相对顺序。
各种排序算法的性能总结
不稳定的排序算法有：希尔排序、选择排序、堆排序、快速排序。
--------------------------------------------------
排序方法: 插入排序
时间复杂度 (平均): O(n^2)
时间复杂度 (最坏): O(n^2)
时间复杂度 (最好): O(n)
空间复杂度: O(1)
稳定性: 稳定
--------------------------------------------------
排序方法: 选择排序
时间复杂度 (平均): O(n^2)
时间复杂度 (最坏): O(n^2)
时间复杂度 (最好): O(n^2)
空间复杂度: O(1)
稳定性: 不稳定
这种“交换”操作可能会跨越很长的距离，从而可能改变等值元素的相对顺序。
--------------------------------------------------
排序方法: 快速排序
时间复杂度 (平均): O(n log n)
时间复杂度 (最坏): O(n^2)
时间复杂度 (最好): O(n log n)
空间复杂度: O(log n)
稳定性: 不稳定
选择基准然后分区，把比基准小的放在基准左边，把比基准大的放在基准右边，然后递归，涉及到了交换
--------------------------------------------------
排序方法: 归并排序
时间复杂度 (平均): O(n log n)
时间复杂度 (最坏): O(n log n)
时间复杂度 (最好): O(n log n)
空间复杂度: O(n)
稳定性: 稳定
--------------------------------------------------
★★★★★★归并排序的最坏时间复杂度优于快排，为什么我们还是选择快排？
快速排序通常比归并排序更快。尽管快速排序在最坏情况下的性能可能较差，但在大多数情况下，它的平均时间复杂度要比归并排序低。
快速排序是原地排序算法。原地排序算法是指排序过程中不需要额外的存储空间，只利用原始输入数组进行排序。
快速排序的实现相对简单。相比于归并排序，快速排序的实现更为简洁，代码量更少。
总结：由于快速排序在平均情况下表现更好、占用更少的空间并且更易于实现。
--------------------------------------------------
排序方法: 希尔排序
时间复杂度 (平均): O(n^1.3) (近似值)
时间复杂度 (最坏): O(n^2)
时间复杂度 (最好): O(n)
空间复杂度: O(1)
稳定性: 不稳定
--------------------------------------------------
排序方法: 堆排序
时间复杂度 (平均): O(n log n)
时间复杂度 (最坏): O(n log n)
时间复杂度 (最好): O(n log n)
空间复杂度: O(1)
稳定性: 不稳定
--------------------------------------------------
排序方法: 冒泡排序
时间复杂度 (平均): O(n^2)
时间复杂度 (最坏): O(n^2)
时间复杂度 (最好): O(n)
空间复杂度: O(1)
稳定性: 稳定
--------------------------------------------------






## KMP算法





## 满二叉树和完全二叉树有什么区别？
- 满二叉树高度为h。结点的个数就是2^h-1，除了最后一层叶子结点，所有的结点都有两个孩，每一层都是满的
- 完全二叉树就是在满二叉树的基础上，最后一层从右往左删除一些叶子节点，如果一个结点只有一个叶子结点那一定是左孩子

## 由遍历序列构造二叉树
- 由二叉树的先序序列和中序序列可以唯一地确定一棵二叉树。
- 由二叉树的后序序列和中序序列也可以唯一地确定一棵二叉树。
- 由二叉树的层序序列和中序序列也可以唯一地确定一棵二叉树
- 需要注意的是，若只知道二叉树的先序序列和后序序列，则无法唯一确定一棵二叉树。
- 一定要有中序遍历

## 树的存储结构？


## 二叉搜索树 BST
- 性质；非空左子树的所有键值<根节点键值，非空右子树所有值>根节点键值，左右子树都是二叉搜索树
- 对二叉搜索树进行中序排序会得到排序好的数组，
- 理想情况下的查找速度可以用 O(logn) 来衡量 最差的情况就是非常不平衡退化成链表 于是产生了AVL

## 平衡二叉树 AVL
- 本质是BST，对于树中的任意一个节点，其左子树的深度（高度）与右子树的深度之差的绝对值不能超过1。
- 平衡因子 = 某节点的左子树深度 - 右子树深度，任意结点的平衡因子只能是+1 -1 0
- AVL树在查找操作上能始终保持 O(logn) 的时间复杂度，即使在最坏情况下也是如此。

## 红黑树 RBT
- 根节点和所有叶子结点都是黑色
- 如果一个结点是红色，那他的两个子节点都是黑色，表示不允许出现两个连续的红色结点
- 从任一特定结点到其所有后代叶子结点的路径上黑色结点数量相同


## B树
- 和二叉树不同，可以有多个子节点，B树通常用于数据库和文件系统。
- 什么是B树的阶 ？B树中一个节点的子节点数目的最大值 
- 一棵m阶B树的性质：
    - 每个节点最多只有m个子节点。
    - 每个非叶子节点（除了根）具有至少⌈m/2⌉子节点。
    - 如果根不是叶节点，则根至少有两个子节点。
    - 具有k个子节点的非叶节点包含k -1个键。
    - 所有叶子都出现在同一水平，位于同一层（高度一致）。\


## 什么是哈夫曼树？如何构造？哈夫曼树的应用
- 关键是最小的带权路径长度WPL，哈夫曼树又称为最优二叉树，其特点是，给定一组带权的叶子结点，若构造所得到的二叉树拥有最小的带权路径长度WPL，则称该二叉树为一棵哈夫曼树。
- 构造办法：首先在集合中挑选出两个权值最小的叶子结点进行合并得到新的结点加入集合，再将两个被选中的结点剔除出集合。在树的构造上，将这两个结点作为叶子结点衔接到合并而成的新结点上。重复以上过程直到集合中只有一个元素，哈夫曼树则完成构造。
- 哈夫曼编码能够保证是前缀码，消除编码的二义性，即每个编码都不是另一个编码的前缀。哈夫曼编码能够保证字符编码总长最短
- 所以，哈夫曼编码的性质有：１，哈夫曼编码是前缀码２，哈夫曼编码是最优前缀码

## 简单介绍dfs和bfs
- dfs是使用栈进行深度优先搜索，按照一个路径一直访问到底，
- bfs是使用队列使用广度优先搜索，先访问源点，然后访问它的相邻结点，根据每个相邻结点的访问，依次继续访问他们的邻居结点
- dfs找到可行解 bfs找到最短路径
